# Multi container apps

앱을 단일 컨테이너로 실행하는 것이 아니라 여러 컨테이너로 구성하여 실행할 수 있다.<br/>
(예를들면 웹 서버와 데이터베이스 컨테이너를 별도로 실행할 수 있다)

## Why?

<strong>일반적으로 각 컨테이너는 하나의 작업만 수행해야 한다.</strong><br/><br/>
왜냐면 각기 다른 성격의 컨테이너는 다르게 확장해야 할 가능성이 높기 때문이다. 때문에 별도의 컨테이너를 통해 각각 격리하여 업데이트하고 버전을 관리할 수 있다.<br/><br/>
위의 예시를 가져오면 "앱을 데이터베이스와 다르게 확장해야 할 가능성이 높다"라고 표현할수 있다.<br/><br/>
데이터베이스를 로컬 컨테이너로 사용할 수 있지만, 프로덕션에서는 외부의 데이터베이스에 관리 서비스를 사용할 확률이 높다.<br/> 즉, 데이터베이스를 앱과 동일한 컨테이너에서 함께 제공하지 않기 때문에, 여러 프로세스를 실행하려면 프로세스 관리자가 필요하게 된다.<br/><Br/>
이로 인해 컨테이너가 복잡해진다<br/>(기본적으로 컨테이너는 프로세스를 하나만 시작함)

## How?

**_컨테이너 네트워킹을 통해 여러개의 컨테이너를 하나의 앱에서 실행할 수 있다._**

# Docker Network

컨테이너 네트워크는 컨테이너가 서로 연결하거나 도커가 아닌 워크로드와 연결하고 통신하는 기능을 의미한다.

`none` 네트워크 드라이버를 사용하지 않는한, 컨테이너는 **IP 주소, 게이트웨이, 라우팅 테이블, DNS 서비스 및 기타 네트워킹 세부 정보가 포함된 네트워크 인터페이스**를 볼 수만 있다.

기본적으로 `docker create` 또는 `docker run`을 사용하여 컨테이너를 생성하거나 실행할 때 컨테이너는 해당 포트를 외부에 노출하지 않으며, 외부 서비스에 포트를 노출하려면 `--publish` 또는 `-p` 플래그를 사용해야 한다.

그러면 호스트에 방화벽 규칙이 생성되어 컨테이너 포트를 외부 서비스로 연결하기 위한 Docker 호스트의 포트에 매핑한다.

```bash
# Docker 호스트의 포트 8080을 컨테이너의 TCP 포트 80에 매핑한다.
docker run -p 8080:80
```

# IP address and hostname

Docker 데몬은 컨테이너에 대한 동적 서브넷 및 IP 주소 할당을 수행한다. 각 네트워크에는 기본 서브넷 마스크와 게이트웨이가 있다.

컨테이너는 `--network` 를 사용하여 단일 네트워크에만 연결할 수 있다. 추가 네트워크 연결은 `docker network connect` 명령어를 사용한다.

`--ip` 또는 `--ipv6` 를 사용하여 지정 IP 할당도 할 수 있다.

hostname은 기본적으로 도커 컨테이너 아이디가 되고 —hostname를 사용하여 직접 지정할수도 있다.

`docker network connect` 를 사용하여 연결할 경우 —alias를 사용하여 추가 네트워크 별칭을 지정할 수도 있다.

# DNS services

도커는 내장형 DNS 서버를 제공하고 사용자 정의 네트워크에 컨테이너가 접속하게 되면 해당 DNS 서버를 사용할 수 있다.

`docker run`, `docker create` 명령어의 옵션을 통해 dns를 설정할 수 있다.

- —dns
- —dns-search:
- —dns-opt
- —hostname

# Custom hosts

기본적으로 호스트 시스템의 /etc/hosts 파일은 컨테이너로 상속되지 않는다. hosts 파일을 컨테이너에게 추가로 전달하고 싶은 경우 `docker run --add-host` 옵션을 사용해야 한다.

# Docker Network Driver

Docker 네트워크 서브 시스템은 pluggable하고, 드라이버를 사용한다.

핵심 네트워크 기능은 다음과 같다.

## Bridge network driver

네트워크 관점에서 브릿지는 Data Link Layer에서 여러 네트워크 세그먼트(LAN)를 연결시켜주는 하드웨어 또는 소프트웨어 장치를 의미한다.

도커 관점에서 브릿지 네트워크는 동일한 브릿지 네트워크에 연결된 컨테이너가 통신할 수 있도록 하는 동시에 해당 브릿지 네트워크에 연결되지 않은 컨테이너로부터 격리를 제공하는 소프트웨어 브릿지를 제공한다.

- 브릿지 네트워크는 **동일한 Docker 데몬 호스트**에서 실행되는 컨테이너에 적용된다.
  - 다른 Docker 데몬 호스트와 통신하기 위해서는 OS 수준에서 경로를 관리하거나, 오버레이 네트워크를 사용해야 한다.
- Docker를 시작하면 기본 브릿지 네트워크가 자동으로 생성되며, 특별히 지정하지 않는 한 새롭게 시작된 컨테이너는 이에 연결된다.
  - 또한 사용자가 정의한 사용자 정의 커스텀 브릿지 네트워크를 생성할 수 있다.
  - 사용자 정의 브릿지 네트워크는 기본 브릿지 네트워크보다 우수하다.

### 사용자 정의 브릿지 네트워크와 기본 브릿지 네트워크와의 차이점

- 사용자 정의 브리지는 컨테이너 간 자동 DNS resolution을 제공한다.
  - 기본 브릿지 네트워크는 IP로만 통신해야 한다.
- 더 나은 격리 환경을 제공한다.
  - 기본적으로 --network 옵션을 통해 지정되지 않은 컨테이너는 기본 브릿지 네트워크로 연결되기 때문이다.
- 컨테이너는 사용자 정의 네트워크에 즉시 연결 및 분리될 수 있다.
  - 기본 브릿지 네트워크의 경우 새로 연결할 때 네트워크 옵션을 새로 만들어야 하기 때문이다.
- 사용자 구성이 가능한 브릿지를 만들 수 있다.
- 기본 브리지 네트워크의 연결된 컨테이너는 환경 변수를 공유한다.

## Overlay network driver

> Overlay 네트워크란?  
> 물리적인 것이 아닌 기존의 논리적인 네트워크 위에 구축되는 컴퓨터 네트워크이다. 오버레이 네트워크 안의 노드는 가상, 논리 링크로 연결될 수 있으며, 각 링크는 네트워크 안에서 많은 물리적 링크를 통하지만 물리적 링크를 고려하지는 않는다. P2P 네트워크는 오버레이 네트워크라고 할 수 있다.

오버레이 네트워크(Overlay Network)는 Docker 스웜(Swarm)에서 사용되는 가상화된 네트워크이다. 이 네트워크는 여러 대의 Docker 호스트 간에 컨테이너들이 통신할 수 있도록 해준다.

스웜을 초기화하거나 기존의 스웜에 Docker 호스트를 추가할 때, 해당 Docker 호스트에는 두 개의 새로운 네트워크가 생성된다.

> 스웜(Swarm)은 Docker의 내장된 오케스트레이션(Orchestration) 도구로, 여러 대의 Docker 호스트를 클러스터로 관리하고 컨테이너화된 애플리케이션을 배포하고 실행하는 기능을 제공하는 도구이다.

1. ingress network (인그레스 네트워크): 이 네트워크는 스웜 서비스를 위한 네트워크로, 외부 트래픽이 스웜 서비스로 진입하는 데 사용된다.
2. overlay network (오버레이 네트워크): 스웜 서비스 간 통신을 위한 내부 네트워크로, 스웜에 속한 서비스들 간에 통신할 수 있도록 설정된다.

이렇게 두 개의 새로운 네트워크가 스웜 초기화나 스웜에 호스트를 추가할 때 생성되어, 외부 트래픽의 인입 및 스웜 내부의 서비스 간 통신을 지원한다.

## Host network driver

컨테이너에 호스트 네트워크 모드(host network mode)를 사용한다면, 해당 컨테이너의 네트워크 스택은 도커 호스트의 네트워크 스택을 사용한다.

- 컨테이너가 호스트의 네트워크 네임스페이스를 공유한다.
- 컨테이너에 고유한 IP 주소가 할당되지 않는다.
  - 예를 들어, 포트 80에 바인딩된 컨테이너를 실행하고 호스트 네트워킹을 사용하면, 해당 컨테이너의 응용 프로그램은 호스트의 IP 주소의 80번 포트에서 이용 가능하다.

> 컨테이너가 고유 IP 주소를 갖지 않기 때문에 `-p`, `--publish`, `-P`, `--publish-all`과 같은 옵션들은 무시된다.

호스트 네트워크 모드는 다음과 같은 사례에 유용할 수 있다.

- 성능 최적화 할 때
- 넓은 범위의 포트를 컨테이너가 핸들링해야 하는 상황일 때

호스트 네트워크 모드가 NAT를 수행하지 않으며, 각 포트에 대한 "userland-proxy"가 생성되지 않는다.

> userland-proxy는 Docker 컨테이너 내에서 포트 매핑을 처리하는 프로세스이다. 이 프록시는 Docker의 네트워킹 시스템을 통해 호스트와 컨테이너 간의 포트 연결을 관리하고 데이터를 전달하는 역할을 한다.  
> `docker run -p` 또는 `docker compose`와 같은 명령어를 사용하여 포트 매핑을 할 때 해당 프로세스가 작동하여 포트를 연결한다.  
> userland-proxy는 네트워크 성능에 일부 영향을 미칠 수 있으며, 컨테이너와 호스트 간의 포트 매핑을 관리하고 중계하는 추가적인 오버헤드가 발생할 수 있다.

## IPvlan network driver

IPvlan은 호스트의 네트워크 인터페이스에 직접 연결되어, 컨테이너를 위한 가상 네트워크 인터페이스를 생성한다.

IPvlan 드라이버를 사용하면 컨테이너는 호스트의 IP 주소 공간에서 직접적으로 통신할 수 있으므로, 컨테이너 간의 통신이 빠르고 효율적으로 이루어질 수 있다.

또한 다양한 모드를 제공한다.

### IPvlan L2 mode

IPvlan L2 모드는 컨테이너의 네트워크 트래픽을 호스트의 L2 레이어에서 처리한다.
이 모드에서 컨테이너는 호스트의 네트워크 인터페이스에 대한 가상 인터페이스로써 동작하며, L2에서 직접 통신하여 네트워크 트래픽을 주고받는다.

![IPvlan L2 mode](https://docs.docker.com/network/drivers/images/macvlan-bridge-ipvlan-l2.webp?w=700)

### IPvlan 802.1Q trunk L2 mode

이 모드는 802.1Q VLAN 트렁크를 사용하여 컨테이너의 네트워크 트래픽을 처리한다.  
컨테이너는 802.1Q VLAN 태그를 사용하여 다중 VLAN 네트워크에 연결된다.

![IPvlan 802.1Q trunk L2 mode](https://docs.docker.com/network/drivers/images/vlans-deeper-look.webp)

### IPvlan L3 mode

IPvlan L3 모드에서는 컨테이너가 호스트의 네트워크 스택에 직접 연결된다.  
컨테이너는 고유한 IP 주소를 갖고 L3 레이어에서 호스트와 통신한다.

![IPvlan L3 mode](https://docs.docker.com/network/drivers/images/ipvlan-l3.webp?w=500)

### Dual stack IPv4 IPv6 IPvlan L2 mode

이 모드에서는 IPvlan L2 모드를 사용하면서, 컨테이너는 동시에 IPv4와 IPv6 주소를 지원하고 호스트의 L2 레이어에서 통신한다.

### Dual stack IPv4 IPv6 IPvlan L3 mode

이 모드는 IPvlan L3 모드를 사용하면서, 컨테이너는 동시에 IPv4와 IPv6 주소를 가지고 호스트와 L3 레이어에서 통신한다.

### Manually create 802.1Q links

이 모드에서는 사용자가 직접 802.1Q VLAN 링크를 수동으로 생성하여 컨테이너 간의 통신을 구성한다.  
이를 통해 사용자는 VLAN 구성과 관리를 더 세밀하게 조정할 수 있다.

## Macvlan network driver

일부 응용 프로그램은 특히 레거시 응용 프로그램이나 네트워크 트래픽을 모니터링하는 응용 프로그램과 같이 물리적 네트워크에 직접 연결되어야 하는 경우가 있다. 이런 상황에서는 Macvlan 네트워크 드라이버를 사용하여 각 컨테이너의 가상 네트워크 인터페이스에 MAC 주소를 할당하여 이를 물리적 네트워크 인터페이스처럼 보이도록 만들 수 있다. 이를 통해 컨테이너는 물리적 네트워크에 직접 연결된 것처럼 동작한다.

이 경우에는 Docker 호스트에서 Macvlan에 사용할 물리적 인터페이스와 네트워크의 서브넷 및 게이트웨이를 지정해야 한다. 또한, 서로 다른 물리적 네트워크 인터페이스를 사용하여 Macvlan 네트워크를 격리할 수도 있다.

이렇게 하면 각 컨테이너가 물리적인 네트워크에 직접적으로 연결되어야 하는 경우에도 Docker 컨테이너를 실행하고 관리할 수 있게 된다. 이는 특정 유형의 응용 프로그램을 Docker 내에서 보다 쉽게 구동하고 네트워크 환경을 설정할 수 있도록 해준다.

## None(no network)

만약 컨테이너의 네트워킹 스택을 완전히 격리하고 싶다면, 컨테이너를 시작할 때 `--network none` 플래그를 사용할 수 있다. 이 옵션을 사용하면 컨테이너 내부에서는 루프백(loopback) 디바이스만 생성된다.
