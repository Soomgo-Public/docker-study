# Docker (Docker)

## 출현 배경

Docker의 출현 배경은 공식문서의 표현을 빌리자면 `애플리케이션을 인프라에서 분리하여 소프트웨어를 신속하게 제공`하기 위해서이다.

### 웹 서비스

#### 모놀리틱

> 과거에는 주로 하나의 서버에 모든 기능을 구현하는 모놀리틱 구조의 서비스가 많았다.

시간의 흐름에 따라 관심사를 분리하고 복잡도를 낮추기 위해 MVC등 다양한 패턴을 적용했지만,<br/>결국 코드 레벨에서의 적용이기에 궁극적으로는 하나의 서버이다.

#### 마이크로 서비스

> 모놀리틱 구조에서 근대에는 마이크로 서비스 형태로 변화하고 있다

마이크로 서비스는 기능(도메인) 단위로 서버를 분리하는 구조이다.
<br />

즉, 모놀리틱 구조에서 마이크로 서비스 형태로 변화하면서 하나의 어플리케이션에 여러 개의 웹 서비스를 호스팅 해야하는 일이 많아졌다.
<br/><br/>
웹 서버는 24시간 구동이 필요하거나 특정 목적으로 사용되는 프로그램이 많다. 때문에 서버 환경에 따라 동일한 프로그램인데도 설정이 많이 달라지며 동일한 환경의 세팅을 매번 같이 해주는 것은 **_비효율_** 적이다

### _So, Docker has arrived!_

보통 Docker로 `서버를 만다`, `서버를 감싼다`라고 표현한다. 즉, Docker는 서버를 랩핑해서 동일한 서버환경을 `제공`할 수 있다.<br/>
덕분에 마이크로 서비스로 변화하는 요즘 서비스들에게 **_공통된 서버 환경을 제공할 수 있게 된다_**

<br />

## 기본 이해

- Docker는 리눅스 컨테이너로 시작된 기술이다.
  > 리눅스 커널의 LXC기술을 이용해 단일 컴퓨터에서 별도의 컨테이너를 만들어서 개별적인 시스템이 동작하게 만든 기술<br/>(최근에는 lxc가 아닌 자체 기술을 사용한다)
- Docker는 데몬 프로그램이다
  <br/>(항상 실행되고 있다)
- 서버와 클라이언트 구조처럼 요청과 응답이 이루어진다

<br/>

## 이미지

> 스크립트의 집합 (정적파일)

- 레이어 형태로 스크립트가 쌓여서 하나의 이미지가 된다

<br/>

## 컨테이너

> 만들어진 이미지를 실행한다<br/>Docker는 이미지를 만들고 컨테이너로 실행한다.

- 하나의 이미지로 다수의 컨테이너를 실행할 수 있다. (인스턴스)
- 격리 및 보안을 통해 특정 호스트에서 동시에 많은 컨테이너를 실행한다
- 느슨하게 격리된 환경에서 애플리케이션을 패키징하고 실행
  > Docker는 운영체제 레벨에서는 호스트를 사용하고 애플리케이션 환경만 분리한다. (느슨한 고립)

<br />

## 아키텍쳐

위에 기본이해에서 확인했듯, Docker는 요청과 응답이 존재한다. 공식문서에 있는 아래의 글귀를 통해 보다 쉽게 이해할 수 있다.

```
you can connect a Docker client to a remote Docker daemon.
The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface.
```

1. Docker 데몬프로그램으로 항상 실행되어 있다.
2. 터미널 등에서 Docker 명령어를 통해 Docker 데몬에 request를 보내고, 데몬프로그램에서 response를 내린다.

<br />

## Docker는 빠르다 ?

공식문서에서 Docker를 `Fast, consistent delivery of your applications`이라고 표현한다.
<br>
어떤 근거로 공식문서는 Docker를 빠르다고 표현할까?

### VS VM (virtual machine)

> **_VM은 커널까지 말아져있다. 그러나 Docker는 컨테이너끼리 통신이된다_**

#### VM은 하이퍼바이저를 사용하여 물리적 하드웨어 위에 가상 머신을 생성한다.

VM은 독립적인 운영 체제를 실행하는 것처럼 보이며, 각각의 가상 머신은 자체 커널을 가지게 된다. 즉, 각 VM은 자체 운영 체제와 커널을 가지고 있으며, 이러한 가상 머신들은 물리적 하드웨어에서 완전히 격리되어 있다.

<br/>

**_하이버파이저_**

> 하이퍼바이저는 단일 물리적 머신에서 여러 가상 머신을 실행하는 데 사용할 수 있는 소프트웨어를 나타낸다.

<br/>

### Docker는 컨테이너 기반 가상화를 한다.

Docker의 컨테이너는 호스트 운영 체제의 커널을 공유하며, 각 컨테이너는 애플리케이션과 해당 의존성을 격리된 환경에서 실행할 수 있다.

<br/>

즉, Docker 컨테이너끼리는 호스트 운영 체제의 커널을 공유하기 때문에 재부팅도 필요 없으며 (하이퍼바이저 보다) 서로 빠르게 통신할 수 있다.

# Overview

- What is a container?
- What is an image?

## 이미지

> 스크립트의 집합 (정적파일)

- 레이어 형태로 스크립트가 쌓여서 하나의 이미지가 된다

<br/>

## 컨테이너

> 만들어진 이미를 실행한다<br/>Docker는 이미지를 만들고 컨테이너로 실행한다.

- 하나의 이미지로 다수의 컨테이너를 실행할 수 있다. (인스턴스)
- 격리 및 보안을 통해 특정 호스트에서 동시에 많은 컨테이너를 실행한다
- 도커는 이미지 아이디로 제어하는 경우가 꽤 있음
  > 같은 이미지여도 컨테이너별로 아이디를 보유한다 (alias 설정 가능)
- 느슨하게 격리된 환경에서 애플리케이션을 패키징하고 실행
  > Docker는 운영체제 레벨에서는 호스트를 사용하고 애플리케이션 환경만 분리한다. (느슨한 고립)
- 리눅스의 커널 네임스페이스, cgroups 기능을 활용한다.
  - 컨테이너는 chroot의 확장 버전으로 생각할 수 있다.
  - 파일 시스템은 이미지에서 가져오지만 컨테이너는 chroot를 사용할 때 제공되지 않는 추가적인 격리를 진행한다.

<br><hr><br>

- 도커는 결국 어떠한 서비스를 실행시키기 위한 컨테이너이다. 때문에 “COMMAND”부분에 서비스 관련 환경을 적는다

# Genie's Action items

## IPC

IPC는 Inter Process Communication의 약자로, 프로세스 간 통신을 가능하게 하는 메커니즘이나 프로토콜을 가리키는 용어이다

### 종류

- 파이프
  > 두 프로세스 간에 단방향 통신을 제공하는 메커니즘입니다. 주로 부모 프로세스와 자식 프로세스 간에 사용.
- 메시지 큐
  > 프로세스 간에 데이터를 `비동기`적으로 전송. 메시지를 큐에 보내고 받는 방식.
  > 생각해보면 채팅 구현할때 자주 접하는 구조인데, 당연했지만, 채팅을 생각해보면 서로 다른 프로세스의 통신이었다..!
- 공유 메모리
  > 두 프로세스가 같은 물리적 메모리 공간을 공유한다.
- 소켓
- 파일
- 시그널
  > UNIX 및 유닉스 기반 시스템에서 사용되는 방법 중 하나.
  > 프로세스에 특정 이벤트 또는 동작을 알리기 위해 사용된다.

<br/>

**_IPC라는 용어가 생소했지만, 생각해보니, 알게 모르게 다른 프로세스간 통신을 위해 이거저거 해봤던것 같다_**

<br />

## Docker Cahcing

<img src="https://github.com/mash-up-kr/moit-web/assets/82315118/b8955b84-b015-4856-90f6-61bde87baa50" alt="" />

### 나의 궁금

```
1. Docker 이미지에 [1,2,3,4,5]의 스크립트가 있고 3번 스크립트에 변경사항이 있다고 가정해보자
2. [3,4,5]만 재실행도 아니고, 3만 재실행하려면 diff를 캐치하는 시스템이 있을텐데 ?
3. 기본으로 제공하는 걸까 ? 아니면 어떤 옵션을 통해 구현이 가능한걸까 ?
4. 구현했다면 어떤 논리일까
```

#### 내 생각이 맞았다.

> 해당 궁금중은 Docker의 공식 문서에 아주 잘 나와 있었다.
> https://docs.docker.com/build/cache

<img src="https://github.com/Soomgo-public/docker-study/assets/82315118/f5a567f2-877e-43ff-b63e-e01834773299" />

<br/>

사진에서 보면 알 수 있듯, Docker는 레이어 단위로 캐싱할 수 있다. 따라서 3이 변경되면, 3에 영향을 받을 4와 5는 무조건적으로 재실행된다.
<br/>
<br/>
즉, 처음 궁금증을 유발한 `only those layers which have changed are rebuilt`는 변화가 있는 레이어만 리빌드된다기 보다는, 해당 레이어부터 새롭게 이미지를 만드는 것으로 해석하는게 맞을듯 하다...

### 결론적으로

Docker의 캐싱을 효과적으로 사용하려면 `Dockerfile`에 스크립트를 작성할 때 몇 가지를 유의해야한다.

- **_스크립트 작성 순서는 논리적으로_**
  > 당연하지만 기존 스크립트에 변경을 주는 내용은 후의 순서로 진행하여 최대한 변화를 덜 발생시키는게 좋다.
- **_Use multi-stage builds_**

  > Dockerfile을 여러 개별 단계로 분할할 수 있다.
  > 각 단계는 빌드 프로세스의 한 단계를 완료하며, 마지막에 여러 단계를 연결하여 최종 이미지를 생성할 수 있다.
  >
  > 해당 분리를 통해 단계 간 종속성을 해결하고, 여러 개의 빌드를 동시에 실행할 수도 있다.
  >
  > multi stage builds는 두 개 이상의 FROM명령을 사용한다.

- **_Docker 명령어를 스크립트 명령과 결합하라_**
  > Docker 대부분의 명령어는 스크립트 명령어와 함께쓸 수 있다. 특히 `RUN` 명령어는 스크립트 명령어와 함께쓰면 좋다.
  >
  > **_Bad_**
  >
  > ```
  > RUN echo "the first command"
  > RUN echo "the second command"
  > ```
  >
  > **_Good_**
  >
  > ```
  > RUN echo "the first command" && echo "the second command"
  > ```

## 표준 스트림

리눅스는 프로그램 실행시 3 개의 스트림이 오픈 됨.

- 표준 입력(STDIN)
- 표준 출력(STDOUT)
- 표준 에러(STDERR)

운영 체제에서 기본적으로 제공하는 추상화된 I/O를 의미.<br/>
일반적으로 입출력은 시스템에 연결된 키보드와 모니터를 통해서 일어나며, 표준 스트림은 이를 추상화했으므로 기본 입출력 장치는 다음처럼 설정된다.

- 표준입력(STDIN): 입력 장치. ID는 0, 일반적으로는 키보드가 된다.
- 표준출력(STDOUT): 출력 장치. ID는 1, 일반적으로는 현재 쉘을 실행한 콘솔이나 터미널.
- 표준에러(STDERR): 에러를 위한 장치. ID 는 2, 일반적으로는 표준 출력과 동일하다.

## chroot

`chroot (change root)`는 유닉스 기반 운영 체제(리눅스 등)에서 사용되는 시스템 수준의 명령어.<br/>
이 명령어를 통해 특정 디렉토리를 루트 디렉토리로 취급하여 해당 디렉토리를 기준으로 파일 시스템에 액세스할 수 있게 된다.<br/>
(fractal패턴에서 tsconfig 생각하면 좋을듯)<br/>
프로세스가 특정 디렉토리 내에서 실행되도록 강제할 때 유용하다.<br/>

## 커널 네임스페이스

한 프로세스 집합이 다른 리소스 집합을 보고 다른 프로세스 집합이 다른 리소스 집합을 볼 수 있도록 커널 리소스를 분할하는 Linux 커널의 기능.<br/>
즉, 네임스페이스의 주요 기능은 프로세스를 서로 격리.

## cgroups

프로세스 모음의 리소스 사용량 (CPU, 메모리, 디스크 I/O, 네트워크 등)을 제한, 설명, 격리하는 Linux 커널 기능.
<br/>

**_cgruop을 통해_**<br/>

- 프로세스가 사용할 수 있는 특정 리소스를 제한하도록 구성할 수 있다(메모리, CPU, ...)
- 다른 cgroup의 프로세스와 비교하여 프로세스가 사용할 수 있는 리소스의 양을 제어.
- 리소스 제한은 cgroup 수준에서 모니터링 된다.
- 단일 명령으로 cgroup에 있는 모든 프로세스의 상태를 변경할 수 있다.

<br/>

**_네임스페이스는 시스템 리소스의 격리를 제공하고 cgroup은 해당 리소스에 대한 세분화된 제어 및 제한 적용을 허용_**
